const vscode = require("vscode");
const fs = require("fs");
const path = require("path");
const ncp = require("ncp").ncp;

function createCppProject(projectName, projectPath, compilerPath) {
    const projectFolderPath = path.join(projectPath, projectName);

    // Create project folder
    if (!fs.existsSync(projectFolderPath)) {
        fs.mkdirSync(projectFolderPath);
    } else {
        console.error(`Project folder '${projectName}' already exists.`);
        return;
    }

    // Create source folder
    const srcFolderPath = path.join(projectFolderPath, "src");
    fs.mkdirSync(srcFolderPath);

    // Create lib folder
    const libFolderPath = path.join(projectFolderPath, "lib");
    fs.mkdirSync(libFolderPath);

    // Create imgs folder
    const imgsFolderPath = path.join(projectFolderPath, "imgs");
    fs.mkdirSync(imgsFolderPath);

    // Create include folder
    const includeFolderPath = path.join(projectFolderPath, "include");
    fs.mkdirSync(includeFolderPath);

    // Create vscode folder
    const vscodeFolderPath = path.join(projectFolderPath, ".vscode");
    fs.mkdirSync(vscodeFolderPath);

    // Get the compiler path from VSCode settings

    //config.get("C_Cpp.default.compilerPath");
    //const compilerPath = config.get("C_Cpp.default.compilerPath"); // Default if not configured




    // Create tasks.json file
    const tasksJsonContent = {
        tasks: [
            {
                type: "cppbuild",
                label: "build",
                command: compilerPath[0].fsPath,
                args: [
                    "-fdiagnostics-color=always",
                    "-g",
                    "${workspaceFolder}\\src\\*.cpp",
                    "${workspaceFolder}\\src\\*.h",
                    "-o",
                    "${fileDirname}\\${fileBasenameNoExtension}.exe",
                ],
                options: {
                    cwd: "${fileDirname}",
                },
                problemMatcher: ["$gcc"],
                group: {
                    kind: "build",
                    isDefault: true,
                },
                detail: "Task generated by Debugger.",
            },
        ],
        version: "2.0.0",
    };

    const launchJsonContent = {
        version: "0.2.0",
        configurations: [
            {
                name: "C++ Launch",
                type: "cppvsdbg",
                request: "launch",
                program: "${workspaceFolder}/src/main.exe",
                args: [],
                stopAtEntry: false,
                cwd: "${workspaceFolder}",
                environment: [],
                console: "integratedTerminal",
                preLaunchTask: "build",
            },
        ],
    };

    const mainContent = `#include <iostream>

int main() {
    std::cout << "Hello, ${projectName}!" << std::endl;
    return 0;
}
/*If you are using c/c++ microsoft extension, make sure that you are using the same
version of c++ on your vscode c_cpp_properties.json (win32)*/`;
    const fooHContent = `#ifndef Foo_H
#define Foo_H

#endif`;

    const tasksJsonPath = path.join(vscodeFolderPath, "tasks.json");
    fs.writeFileSync(tasksJsonPath, JSON.stringify(tasksJsonContent, null, 2));

    const launchJsonPath = path.join(vscodeFolderPath, "launch.json");
    fs.writeFileSync(
        launchJsonPath,
        JSON.stringify(launchJsonContent, null, 2)
    );

    const mainCppFilePath = path.join(srcFolderPath, "main.cpp");
    fs.writeFileSync(mainCppFilePath, mainContent);

    const fooHFilePath = path.join(srcFolderPath, "Foo.h");
    fs.writeFileSync(fooHFilePath, fooHContent);

    console.log(
        `C++ project '${projectName}' created successfully at '${projectPath}'.`
    );
}

function createOpenGLProject(
    projectName,
    projectPath,
    compilerPath,
    glfwFolder,
    glewFolder,
    openGLDLLPath,
    glfwDLLPath,
    glewDLLPath,
    libGLFWFilePath,
    libGLEWFilePath
) {
    const projectFolderPath = path.join(projectPath, projectName);

    // Create project folder
    if (!fs.existsSync(projectFolderPath)) {
        fs.mkdirSync(projectFolderPath);
    } else {
        console.error(`Project folder '${projectName}' already exists.`);
        return;
    }

    // Create source folder
    const srcFolderPath = path.join(projectFolderPath, "src");
    fs.mkdirSync(srcFolderPath);

    // Create lib folder
    const libFolderPath = path.join(projectFolderPath, "lib");
    fs.mkdirSync(libFolderPath);

    // Create imgs folder
    const imgsFolderPath = path.join(projectFolderPath, "imgs");
    fs.mkdirSync(imgsFolderPath);

    // Create include folder
    const includeFolderPath = path.join(projectFolderPath, "include");
    fs.mkdirSync(includeFolderPath);

    // Create vscode folder
    const vscodeFolderPath = path.join(projectFolderPath, ".vscode");
    fs.mkdirSync(vscodeFolderPath);

    // Copy the content of GLFW folder
    const glfwDestinationPath = path.join(includeFolderPath, "GLFW");
    ncp(glfwFolder, glfwDestinationPath, function (err) {
        if (err) {
            console.error("Error copying GLFW folder:", err);
        } else {
            console.log("GLFW folder copied successfully!");
        }
    });

    // Copy the content of glew (GL) folder
    const glewDestinationPath = path.join(includeFolderPath, "GL");
    ncp(glewFolder, glewDestinationPath, function (err) {
        if (err) {
            console.error("Error copying GLFW folder:", err);
        } else {
            console.log("GLFW folder copied successfully!");
        }
    });

    // include the libs files on the folder lib
    const libGLEWDestinationPath = path.join(
        libFolderPath,
        path.basename(libGLEWFilePath)
    );
    fs.copyFileSync(libGLEWFilePath, libGLEWDestinationPath);

    const libGLFWDestinationPath = path.join(
        libFolderPath,
        path.basename(libGLFWFilePath)
    );
    fs.copyFileSync(libGLFWFilePath, libGLFWDestinationPath);

    // Example: Copy GLFW DLL
    const openGLDLLDestinationPath = path.join(
        projectFolderPath,
        path.basename(openGLDLLPath)
    );
    fs.copyFileSync(openGLDLLPath, openGLDLLDestinationPath);

    // Example: Copy GLFW DLL
    const glfwDLLDestinationPath = path.join(
        projectFolderPath,
        path.basename(glfwDLLPath)
    );
    fs.copyFileSync(glfwDLLPath, glfwDLLDestinationPath);

    // Example: Copy GLEW DLL
    const glewDLLDestinationPath = path.join(
        projectFolderPath,
        path.basename(glewDLLPath)
    );
    fs.copyFileSync(glewDLLPath, glewDLLDestinationPath);


    // Get the compiler path from VSCode settings

    //config.get("C_Cpp.default.compilerPath");
    //const compilerPath = config.get("C_Cpp.default.compilerPath"); // Default if not configured

    // Create tasks.json file
    const tasksJsonContent = {
        tasks: [
            {
                type: "cppbuild",
                label: "build",
                command: compilerPath,
                args: [
                    "-fdiagnostics-color=always",
                    "-g",
                    "-I${workspaceFolder}/include",
                    "-L${workspaceFolder}/lib",
                    "${workspaceFolder}\\src\\*.cpp",
                    "${workspaceFolder}\\src\\*.h",
                    "-lglew32",
                    "-lopengl32",
                    "-lglfw3dll",
                    "-o",
                    "${fileDirname}\\${fileBasenameNoExtension}.exe",
                ],
                options: {
                    cwd: "${fileDirname}",
                },
                problemMatcher: ["$gcc"],
                group: {
                    kind: "build",
                    isDefault: true,
                },
                detail: "Task generated by Debugger.",
            },
        ],
        version: "2.0.0",
    };

    const launchJsonContent = {
        version: "0.2.0",
        configurations: [
            {
                name: "C++ Launch",
                type: "cppvsdbg",
                request: "launch",
                program: "${workspaceFolder}/src/main.exe",
                args: [],
                stopAtEntry: false,
                cwd: "${workspaceFolder}",
                environment: [],
                console: "integratedTerminal",
                preLaunchTask: "build",
            },
        ],
    };

    const mainContent = `#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <iostream>

const char* vertexShaderSource = R"(
    #version 330 core
    layout (location = 0) in vec3 aPos;

    void main() {
        gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);
    }
)";

const char* fragmentShaderSource = R"(
    #version 330 core
    out vec4 FragColor;

    void main() {
        FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);
    }
)";

int main() {
    // Initialize GLFW
    if (!glfwInit()) {
        std::cerr << "Failed to initialize GLFW" << std::endl;
        return -1;
    }

    // Set GLFW to use the OpenGL Core Profile
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    // Create a GLFW window
    GLFWwindow* window = glfwCreateWindow(800, 600, "Hello, ${projectName}!", nullptr, nullptr);
    if (!window) {
        std::cerr << "Failed to create GLFW window" << std::endl;
        glfwTerminate();
        return -1;
    }

    // Make the context of the window the current context
    glfwMakeContextCurrent(window);

    // Initialize GLEW
    if (glewInit() != GLEW_OK) {
        std::cerr << "Failed to initialize GLEW" << std::endl;
        return -1;
    }

    // Vertex Shader
    GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertexShader, 1, &vertexShaderSource, nullptr);
    glCompileShader(vertexShader);

    // Check for shader compile errors
    GLint success;
    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);
    if (!success) {
        GLchar infoLog[512];
        glGetShaderInfoLog(vertexShader, sizeof(infoLog), nullptr, infoLog);
        std::cerr << "ERROR: Vertex shader compilation failed" << infoLog << std::endl;
    }

    // Fragment Shader
    GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragmentShader, 1, &fragmentShaderSource, nullptr);
    glCompileShader(fragmentShader);

    // Check for shader compile errors
    glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &success);
    if (!success) {
        GLchar infoLog[512];
        glGetShaderInfoLog(fragmentShader, sizeof(infoLog), nullptr, infoLog);
        std::cerr << "ERROR: Fragment shader compilation failed" << infoLog << std::endl;
    }

    // Link shaders into a program
    GLuint shaderProgram = glCreateProgram();
    glAttachShader(shaderProgram, vertexShader);
    glAttachShader(shaderProgram, fragmentShader);
    glLinkProgram(shaderProgram);

    // Check for linking errors
    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);
    if (!success) {
        GLchar infoLog[512];
        glGetProgramInfoLog(shaderProgram, sizeof(infoLog), nullptr, infoLog);
        std::cerr << "ERROR: Shader program linking failed" << infoLog << std::endl;
    }

    // Clean up shaders (no longer needed)
    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);

    // Set up vertex data
    GLfloat vertices[] = {
        -0.5f, -0.5f, 0.0f,
         0.5f, -0.5f, 0.0f,
         0.0f,  0.5f, 0.0f
    };

    // Set up Vertex Array Object, Vertex Buffer Object, and Element Buffer Object
    GLuint VAO, VBO;
    glGenVertexArrays(1, &VAO);
    glGenBuffers(1, &VBO);

    // Bind the Vertex Array Object first, then bind and set vertex buffer(s) and attribute pointer(s).
    glBindVertexArray(VAO);

    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

    // Set the attribute pointer
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0);
    glEnableVertexAttribArray(0);

    // Unbind VAO (it's always a good idea to unbind any buffer/array to prevent strange bugs)
    glBindVertexArray(0);

    // Main loop
    while (!glfwWindowShouldClose(window)) {
        // Render here...
        glClear(GL_COLOR_BUFFER_BIT);

        // Use our shader program
        glUseProgram(shaderProgram);

        // Bind the VAO
        glBindVertexArray(VAO);

        // Draw the triangle
        glDrawArrays(GL_TRIANGLES, 0, 3);

        // Unbind the VAO
        glBindVertexArray(0);

        // Swap front and back buffers
        glfwSwapBuffers(window);

        // Poll for and process events
        glfwPollEvents();
    }

    // Clean up VAO and VBO
    glDeleteVertexArrays(1, &VAO);
    glDeleteBuffers(1, &VBO);

    // Terminate GLFW
    glfwTerminate();

    return 0;
}
`;
    const fooHContent = `#ifndef Foo_H
#define Foo_H

#endif`;

    const tasksJsonPath = path.join(vscodeFolderPath, "tasks.json");
    fs.writeFileSync(tasksJsonPath, JSON.stringify(tasksJsonContent, null, 2));

    const launchJsonPath = path.join(vscodeFolderPath, "launch.json");
    fs.writeFileSync(
        launchJsonPath,
        JSON.stringify(launchJsonContent, null, 2)
    );

    const mainCppFilePath = path.join(srcFolderPath, "main.cpp");
    fs.writeFileSync(mainCppFilePath, mainContent);

    const fooHFilePath = path.join(srcFolderPath, "Foo.h");
    fs.writeFileSync(fooHFilePath, fooHContent);

    console.log(
        `C++ project '${projectName}' created successfully at '${projectPath}'.`
    );
}

function createCppClass(className, filePath) {
    //const folderPath = path.dirname(filePath);
    const folderPath = filePath;
    const cppCode = `#include "${className}.h"
    #include <iostream>
    using namespace std;

${className}::${className}() {}

${className}::~${className}() {}

`;

    const hCode = `#ifndef ${className}_H
#define ${className}_H

class ${className} {
private:
public:
    ${className}();
    ~${className}();
};

#endif
`;

    const cppFileName = `${className}.cpp`;
    const hFileName = `${className}.h`;

    const cppFilePath = path.join(folderPath, cppFileName);
    const hFilePath = path.join(folderPath, hFileName);

    // Check if the files already exist
    if (fs.existsSync(cppFilePath) || fs.existsSync(hFilePath)) {
        vscode.window.showErrorMessage(
            `Files already exist for ${className} in the selected folder.`
        );
        return;
    }

    // Write the Cpp file
    fs.writeFile(cppFilePath, cppCode, (err) => {
        if (err) {
            vscode.window.showErrorMessage(
                `Error creating ${cppFileName}: ${err.message}`
            );
        } else {
            vscode.window.showInformationMessage(
                `${cppFileName} created successfully!`
            );
            vscode.workspace
                .openTextDocument(cppFilePath)
                .then(vscode.window.showTextDocument);
        }
    });

    // Write the header file
    fs.writeFile(hFilePath, hCode, (err) => {
        if (err) {
            vscode.window.showErrorMessage(
                `Error creating ${hFileName}: ${err.message}`
            );
        } else {
            vscode.window.showInformationMessage(
                `${hFileName} created successfully!`
            );
            vscode.workspace
                .openTextDocument(cppFilePath)
                .then(vscode.window.showTextDocument);
        }
    });
}

/* function generateConstructor() {
    const editor = vscode.window.activeTextEditor;

    if (editor || path.extname(editor.document.uri.fsPath) === ".h") {
        // Get the entire content of the .h file
        const document = editor.document;
        const entireFileRange = new vscode.Range(
            0,
            0,
            document.lineCount - 1,
            document.lineAt(document.lineCount - 1).text.length
        );
        const fileContent = document.getText(entireFileRange);

        // Regular expression to match C++ attribute declarations
        const attributeRegex = /\b\w+(?:\s*\*)?\s+(\w+)\s*;/g;
        //const attributeRegex = /\b\w+(?:\s*\*)?(?:\s*\*\s*\w+)?\s+(\w+)\s*;/g;

        // Map to store variable names and their types
        const variableTypes = new Map();

        // Find all attribute declarations in the file content
        let match;
        while ((match = attributeRegex.exec(fileContent)) !== null) {
            const variableName = match[1];
            const variableType = match[0].match(/\b\w+(?:\s*\*)?/)[0].trim();
            variableTypes.set(variableName, variableType);
        }

        const className = path.basename(editor.document.uri.fsPath, path.extname(editor.document.uri.fsPath));
        
        
        const constructorParameters = Array.from(variableTypes)
            .map(([variable, type]) => `${type} ${variable}`)
            .join(', ');

            const variableAssignments = Array.from(variableTypes)
            .map(([variable]) => `    this->${variable} = ${variable};`)
            .join('\n');

        const constructorText = `${className}::${className}(${constructorParameters}) {
            ${variableAssignments}
        }`;

        // Generate the constructor
        editor.edit((editBuilder) => {
            editBuilder.insert(
                editor.selection.start,
                constructorText
            );
            vscode.window.showInformationMessage(
                "Getters And Setters generated!"
            );
        });

    }
}
 */

function generateGetSet() {
    function generateGetters(variableTypes, existingGettersSetters) {
        // Generate getter methods for each attribute that is not already defined
        const getters = Array.from(variableTypes).map(([variable, type]) => {
            let upperVar = variable.charAt(0).toUpperCase() + variable.slice(1);
            const getterName = `get${upperVar}`;

            // Check if the getter for the variable already exists
            if (!existingGettersSetters.includes(getterName)) {
                return `\t${type} ${getterName}() const { return ${variable}; }\n`;
            } else {
                return ""; // Empty string for variables with existing getters
            }
        });

        return getters.join("\n");
    }

    function generateSetters(variableTypes, existingGettersSetters) {
        // Generate setter methods for each attribute that is not already defined
        const setters = Array.from(variableTypes).map(([variable, type]) => {
            let upperVar = variable.charAt(0).toUpperCase() + variable.slice(1);
            const setterName = `set${upperVar}`;

            // Check if the setter for the variable already exists
            if (!existingGettersSetters.includes(setterName)) {
                return `\tvoid ${setterName}(${type} value) { ${variable} = value; }\n`;
            } else {
                return ""; // Empty string for variables with existing setters
            }
        });

        return setters.join("\n");
    }

    const editor = vscode.window.activeTextEditor;

    if (editor || path.extname(editor.document.uri.fsPath) === ".h") {
        // Get the entire content of the .h file
        const document = editor.document;
        const entireFileRange = new vscode.Range(
            0,
            0,
            document.lineCount - 1,
            document.lineAt(document.lineCount - 1).text.length
        );
        const fileContent = document.getText(entireFileRange);

        // Regular expression to match C++ attribute declarations
        const attributeRegex = /\b\w+(?:\s*\*)?\s+(\w+)\s*;/g;
        //const attributeRegex = /\b\w+(?:\s*\*)?(?:\s*\*\s*\w+)?\s+(\w+)\s*;/g;

        // Map to store variable names and their types
        const variableTypes = new Map();

        // Find all attribute declarations in the file content
        let match;
        while ((match = attributeRegex.exec(fileContent)) !== null) {
            const variableName = match[1];
            const variableType = match[0].match(/\b\w+(?:\s*\*)?/)[0].trim();
            variableTypes.set(variableName, variableType);
        }

        // Regular expression to match C++ getter and setter declarations
        const getterSetterRegex =
            /\b(\w+)\s+get(\w+)\s*\(\)\s*const\s*{\s*return\s*\w+\s*;\s*}\s*\n\s*(?:\bvoid\s+set(\w+)\s*\((\w+)\s+\w+\)\s*{\s*\w+\s*=\s*\w+\s*;\s*}\s*\n)?/g;

        // Find all existing getter and setter declarations in the file content
        let existingGettersSetters = [];
        while ((match = getterSetterRegex.exec(fileContent)) !== null) {
            let getterName = match[2];
            let setterName = match[3];
            if (getterName) {
                getterName =
                    match[2].charAt(0).toUpperCase() + match[2].slice(1);
                existingGettersSetters.push(`get${getterName}`);
            }
            if (setterName) {
                setterName =
                    match[3].charAt(0).toUpperCase() + match[3].slice(1);
                existingGettersSetters.push(`set${setterName}`);
            }
        }

        const generatedGetters = generateGetters(
            variableTypes,
            existingGettersSetters
        );
        const generatedSetters = generateSetters(
            variableTypes,
            existingGettersSetters
        );

        // Joining both and removing first \t or \n
        let aux = generatedGetters + "\n" + generatedSetters;
        while (
            (aux = aux.substring(1)).charAt(0) == "\n" ||
            aux.charAt(0) == "\t"
        ) {}
        const generatedGettersAndSetters = aux;

        // Generate setters and insert them at the current cursor position
        editor.edit((editBuilder) => {
            editBuilder.insert(
                editor.selection.start,
                generatedGettersAndSetters
            );
            vscode.window.showInformationMessage(
                "Getters And Setters generated!"
            );
        });
    }
}

function generateFunctionBodiesCpp() {
    const editor = vscode.window.activeTextEditor;

    if (editor) {
        // Get the current file's URI
        const currentUri = editor.document.uri;
        console.log("Current URI:", currentUri.toString());

        // Derive the URI for the corresponding header file (.h)
        const cppFilePath = currentUri.fsPath;
        const headerFilePath = cppFilePath.slice(0, -3) + "h";

        console.log("Header URI:", headerFilePath.toString());
        const headerUri = vscode.Uri.file(headerFilePath);

        // Check if the header file exists
        if (fs.existsSync(headerFilePath)) {
            vscode.workspace.openTextDocument(headerUri).then(
                (document) => {
                    console.log(document.getText());
                    // Regular expression to match C++ function declarations
                    const functionRegex =
                        /\b(\w+)+(?:\s*\*)?\s+(\w+)\s*\(([\s\S]*?)\)\s*;(\s*)/g;

                    // Map to store function names, return types, and parameters
                    const functionInfo = new Map();

                    // Find all function declarations in the header file content
                    let match;
                    while (
                        (match = functionRegex.exec(document.getText())) !==
                        null
                    ) {
                        const returnType = match[0]
                            .match(/\b\w+(?:\s*\*)?/)[0]
                            .trim();
                        const functionName = match[2];
                        const parameters = match[3].trim(); // Trim to remove leading/trailing whitespace
                        functionInfo.set(functionName, {
                            returnType,
                            parameters,
                        });
                    }

                    // Getting the className
                    const filePath = editor.document.fileName;
                    const className = path.basename(
                        filePath,
                        path.extname(filePath)
                    );

                    // Regular expression to match C++ function definitions in the current source file
                    const functionDefinitionRegex =
                        /\b(\w+)\s+(\w+)\s*::\s*(\w+)\s*\(([\s\S]*?)\)\s*{(\s*)/g;

                    // Find all function definitions in the current source file content
                    let definedFunctions = [];
                    while (
                        (match = functionDefinitionRegex.exec(
                            editor.document.getText()
                        )) !== null
                    ) {
                        const currentClassName = match[2];
                        const currentFunctionName = match[3];
                        definedFunctions.push(
                            `${currentClassName}::${currentFunctionName}`
                        );
                    }

                    // Filter out functions that are already defined in the current source file
                    const undefinedFunctions = Array.from(functionInfo).filter(
                        ([functionName]) =>
                            !definedFunctions.includes(
                                `${className}::${functionName}`
                            )
                    );

                    // Generate function bodies for each undefined function
                    const functionBodies = undefinedFunctions.map(function ([
                        functionName,
                        { returnType, parameters },
                    ]) {
                        return `${returnType} ${className}::${functionName}(${parameters}) {}\n`;
                    });

                    // Insert the generated code at the current cursor position in the cpp file
                    editor.edit(function (editBuilder) {
                        // Add a newline between each function body
                        editBuilder.insert(
                            editor.selection.start,
                            functionBodies.join("\n")
                        );
                    });

                    vscode.window.showInformationMessage(
                        `Function Bodies Generated`
                    );
                },
                (error) => {
                    vscode.window.showErrorMessage(
                        "Corresponding header file not found. " +
                            headerFilePath.toString() +
                            " Try opening the file in the workspace."
                    );
                }
            );
        } else {
            vscode.window.showErrorMessage(
                "Corresponding header file not found. " +
                    headerFilePath.toString() +
                    "Try opening the file in the workspace."
            );
        }
    }
}

function sycronizeDeclarationCpp() {
    const synchronizeFunctionDeclaration = (headerDocument, cppDocument) => {
        const editor = vscode.window.activeTextEditor;
        if (!editor || !editor.document.fileName.endsWith(".cpp")) {
            vscode.window.showErrorMessage("No active C++ file in the editor.");
            return;
        }

        const functionDeclarations = getSelectedFunctionNames(editor);

        // Check if there are any function declarations in the selected text
        if (!functionDeclarations || functionDeclarations.length === 0) {
            vscode.window.showErrorMessage(
                "No function declarations selected."
            );
            return;
        }

        // Initialize updated header content
        let updatedHeaderContent = headerDocument.getText();

        for (let index = 0; index < functionDeclarations.length; index++) {
            const functionDeclaration = functionDeclarations[index];
            let needsUpdate = false;

            // Breaking down the terms
            const returnType = functionDeclaration[0];
            const functionName = functionDeclaration[1];
            const parameters = functionDeclaration[2].trim();
            const functionActualName = functionName.replace(/.*::/, "");

            // Update or create the function declaration in the header file
            const headerRegex = new RegExp(
                `\\b${returnType}\\s+${functionActualName}\\s*\\([^)]*\\)\\s*;`,
                "g"
            );

            const closingBraceIndex = updatedHeaderContent.lastIndexOf("}");

            if (headerRegex.test(updatedHeaderContent)) {
                // Update existing function declaration only if there is a change
                const existingDeclarationMatch =
                    updatedHeaderContent.match(headerRegex);
                const existingDeclaration = existingDeclarationMatch
                    ? existingDeclarationMatch[0]
                    : null;

                const newDeclaration = `${returnType} ${functionActualName}(${parameters});`;

                if (existingDeclaration !== newDeclaration) {
                    updatedHeaderContent = updatedHeaderContent.replace(
                        headerRegex,
                        newDeclaration
                    );
                    needsUpdate = true;
                }
            } else {
                // Add new function declaration right above the closing brace
                if (closingBraceIndex !== -1) {
                    const insertPosition =
                        headerDocument.positionAt(closingBraceIndex);

                    const functionDeclarationText = `\n    ${returnType} ${functionActualName}(${parameters});\n`;

                    // Insert the new function declaration into the updated header content
                    updatedHeaderContent =
                        updatedHeaderContent.slice(0, closingBraceIndex) +
                        functionDeclarationText +
                        updatedHeaderContent.slice(closingBraceIndex);

                    needsUpdate = true;
                } else {
                    vscode.window.showErrorMessage(
                        "Unable to locate closing brace in the header file."
                    );
                }
            }
            if (needsUpdate) {
                // Auxiliary variable to decide show message
                vscode.window.showInformationMessage(
                    `Function "${functionName}" synchronized.`
                );
            }
        }

        // Apply the changes to the header document
        vscode.workspace
            .openTextDocument(headerDocument.uri)
            .then((document) => {
                vscode.window.showTextDocument(document).then((editor) => {
                    editor.edit((editBuilder) => {
                        // Replace the entire content of the header file with the updated content
                        const fullRange = new vscode.Range(
                            new vscode.Position(0, 0),
                            document.lineAt(document.lineCount - 1).range.end
                        );
                        editBuilder.replace(fullRange, updatedHeaderContent);
                    });
                });
            });
    };

    const getSelectedFunctionNames = (editor) => {
        const selection = editor.selection;
        let selectedText = editor.document.getText(selection);
        if (!selectedText) {
            selectedText = editor.document.getText();
        }

        // Assuming the selected text contains multiple function declarations
        const functionRegex = /\b\s*(\w+)\s+(\w+(?:::\w+)?)\s*\(([^)]*)\)\s*{/g;

        let match;
        const functionNames = [];
        // const functionDeclaration = [];
        const functionDeclarations = [];

        while ((match = functionRegex.exec(selectedText)) !== null) {
            functionNames.push(match[2]);
            const functionDeclaration = [];
            functionDeclaration.push(match[1], match[2], match[3]);
            functionDeclarations.push(functionDeclaration);
        }

        return functionDeclarations.length > 0 ? functionDeclarations : null;
    };

    const editor = vscode.window.activeTextEditor;
    const cppFilePath = editor.document.uri.fsPath;
    const headerFilePath = cppFilePath.slice(0, -3) + "h";

    const cppUri = vscode.Uri.file(cppFilePath);
    const headerUri = vscode.Uri.file(headerFilePath);

    vscode.workspace.openTextDocument(cppUri).then(
        (cppDocument) => {
            vscode.workspace.openTextDocument(headerUri).then(
                (headerDocument) => {
                    // Call the function to synchronize based on the selected function in the active editor
                    synchronizeFunctionDeclaration(headerDocument, cppDocument);
                },
                (error) => {
                    vscode.window.showErrorMessage(
                        `Error opening header file: ${headerFilePath}`
                    );
                }
            );
        },
        (error) => {
            vscode.window.showErrorMessage(
                `Error opening cpp file: ${cppFilePath}`
            );
        }
    );
}

function activate(context) {
    let createClassCommandDisposable = vscode.commands.registerCommand(
        "betterCPP.createClass",
        (uri) => {
            // Prompt user for class name
            let folderPath;
            vscode.window
                .showInputBox({
                    prompt: "Enter a name for the C++ class",
                    placeHolder: "MyClass",
                })
                .then((className) => {
                    if (className && uri && uri.fsPath) {
                        folderPath = uri.fsPath;
                        createCppClass(className, folderPath);
                    } else {
                        // If 'resourceUri' is not provided, use the active workspace folder
                        const activeWorkspaceFolder =
                            vscode.workspace.workspaceFolders[0];
                        folderPath = activeWorkspaceFolder
                            ? activeWorkspaceFolder.uri.fsPath
                            : undefined;
                    }
                });
        }
    );

    // Register the command to generate getter and setter methods
    let generateGetSetCommandDisposable = vscode.commands.registerCommand(
        "betterCPP.generateGetSetcpp",
        () => {
            // Get the active text editor
            generateGetSet();
        }
    );

    let generateFunctionBodiesCommandDisposable =
        vscode.commands.registerCommand(
            "betterCPP.generateFunctionBodies",
            () => {
                // Get the active text editor
                generateFunctionBodiesCpp();
            }
        );

    let synchronizeFunctionDeclarationDisposable =
        vscode.commands.registerCommand(
            "betterCPP.syncronizeFunctionDeclaration",
            () => {
                // Get the active text editor
                sycronizeDeclarationCpp();
            }
        );

    let generateProjectCommandDisposable = vscode.commands.registerCommand(
        "betterCPP.generateProjectcpp",
        () => {
            function promptForProjectNameAndCreateProject(
                folderUri,
                compilerPath
            ) {
                vscode.window
                    .showInputBox({
                        prompt: "Enter a name for the C++ project",
                        placeHolder: "MyCppProject",
                    })
                    .then((projectName) => {
                        if (projectName) {
                            createCppProject(
                                projectName,
                                folderUri.fsPath,
                                compilerPath
                            );
                            const projectFolderPath = path.join(
                                folderUri.fsPath,
                                projectName
                            );
                            vscode.commands.executeCommand(
                                "vscode.openFolder",
                                vscode.Uri.file(projectFolderPath),
                                false
                            );
                        }
                    });
            }
            // Prompt the user to select the compiler path
            vscode.window.showInformationMessage(
                "Select folder for C++ COMPILER ex: C:\\MinGW\\bin\\g++.exe"
            );
            vscode.window
                .showOpenDialog({
                    canSelectFiles: true,
                    canSelectFolders: false,
                    canSelectMany: false,
                    openLabel:
                        "Select folder for C++ COMPILER ex: C:\\MinGW\\bin\\g++.exe",
                })
                .then((compilerPath) => {
                    // Continue with project generation if the compiler path is provided
                    if (compilerPath) {
                        // Open file picker dialog to select a folder for the C++ project
                        vscode.window.showInformationMessage(
                            "Select folder for C++ Project"
                        );
                        vscode.window
                            .showOpenDialog({
                                canSelectFiles: false,
                                canSelectFolders: true,
                                canSelectMany: false,
                                openLabel: "Select folder for C++ Project",
                            })
                            .then((folderUri) => {
                                if (folderUri && folderUri.length > 0) {
                                    const selectedFolder = folderUri[0];
                                    promptForProjectNameAndCreateProject(
                                        selectedFolder,
                                        compilerPath
                                    );
                                }
                            });
                    }
                });
        }
    );

    let generateOpenGLProjectCommandDisposable =
        vscode.commands.registerCommand(
            "betterCPP.generateOpenGLProject",
            () => {
                function promptForProjectDetailsAndCreateProject() {
                    vscode.window
                        .showInputBox({
                            prompt: "Enter a name for the OpenGL project",
                            placeHolder: "MyOpenGLProject",
                        })
                        .then((projectName) => {
                            if (!projectName) {
                                vscode.window.showErrorMessage(
                                    "Project name not provided. Aborting project creation."
                                );
                                return;
                            }

                            // Prompt the user to select the compiler path
                            vscode.window.showInformationMessage(
                                "Select folder for C++ COMPILER ex: C:\\MinGW\\bin\\g++.exe"
                            );
                            vscode.window
                                .showOpenDialog({
                                    canSelectFiles: true,
                                    canSelectFolders: false,
                                    canSelectMany: false,
                                    openLabel:
                                        "Select the C++ COMPILER folder ex: C:\\MinGW\\bin\\g++.exe",
                                })
                                .then((compilerPath) => {
                                    // Continue with project generation if the compiler path is provided
                                    if (
                                        !compilerPath ||
                                        compilerPath.length === 0
                                    ) {
                                        vscode.window.showErrorMessage(
                                            "Compiler path not selected. Aborting project creation."
                                        );
                                        return;
                                    }

                                    // Open file picker dialog to select a folder for the OpenGL project
                                    vscode.window.showInformationMessage(
                                        "Select folder for OpenGL Project"
                                    );
                                    vscode.window
                                        .showOpenDialog({
                                            canSelectFiles: false,
                                            canSelectFolders: true,
                                            canSelectMany: false,
                                            openLabel:
                                                "Select folder for OpenGL Project",
                                        })
                                        .then((folderUri) => {
                                            if (
                                                !folderUri ||
                                                folderUri.length === 0
                                            ) {
                                                vscode.window.showErrorMessage(
                                                    "Project folder not selected. Aborting project creation."
                                                );
                                                return;
                                            }

                                            const selectedFolder = folderUri[0];

                                            // Select the GLFW Folder
                                            vscode.window
                                                .showOpenDialog({
                                                    canSelectFiles: false,
                                                    canSelectFolders: true,
                                                    canSelectMany: false,
                                                    openLabel:
                                                        "Select GLFW 'GLFW' folder",
                                                })
                                                .then((glfwFolder) => {
                                                    if (
                                                        !glfwFolder ||
                                                        glfwFolder.length === 0
                                                    ) {
                                                        vscode.window.showErrorMessage(
                                                            "GLFW folder not selected. Aborting project creation."
                                                        );
                                                        return;
                                                    }

                                                    // Select the GLEW Folder
                                                    vscode.window
                                                        .showOpenDialog({
                                                            canSelectFiles: false,
                                                            canSelectFolders: true,
                                                            canSelectMany: false,
                                                            openLabel:
                                                                "Select GLEW GL folder",
                                                        })
                                                        .then((glewFolder) => {
                                                            if (
                                                                !glewFolder ||
                                                                glewFolder.length ===
                                                                    0
                                                            ) {
                                                                vscode.window.showErrorMessage(
                                                                    "GLEW folder not selected. Aborting project creation."
                                                                );
                                                                return;
                                                            }

                                                            // Select the OpenGL DLL
                                                            vscode.window
                                                                .showOpenDialog(
                                                                    {
                                                                        canSelectFiles: true,
                                                                        canSelectFolders: false,
                                                                        canSelectMany: false,
                                                                        openLabel:
                                                                            "Select OpenGL DLL",
                                                                    }
                                                                )
                                                                .then(
                                                                    (
                                                                        openGLDLLPath
                                                                    ) => {
                                                                        if (
                                                                            !openGLDLLPath ||
                                                                            openGLDLLPath.length ===
                                                                                0
                                                                        ) {
                                                                            vscode.window.showErrorMessage(
                                                                                "OpenGL DLL not selected. Aborting project creation."
                                                                            );
                                                                            return;
                                                                        }

                                                                        // Select the GLFW DLL
                                                                        vscode.window
                                                                            .showOpenDialog(
                                                                                {
                                                                                    canSelectFiles: true,
                                                                                    canSelectFolders: false,
                                                                                    canSelectMany: false,
                                                                                    openLabel:
                                                                                        "Select GLFW DLL",
                                                                                }
                                                                            )
                                                                            .then(
                                                                                (
                                                                                    glfwDLLPath
                                                                                ) => {
                                                                                    if (
                                                                                        !glfwDLLPath ||
                                                                                        glfwDLLPath.length ===
                                                                                            0
                                                                                    ) {
                                                                                        vscode.window.showErrorMessage(
                                                                                            "GLFW DLL not selected. Aborting project creation."
                                                                                        );
                                                                                        return;
                                                                                    }

                                                                                    // Select the GLEW DLL
                                                                                    vscode.window
                                                                                        .showOpenDialog(
                                                                                            {
                                                                                                canSelectFiles: true,
                                                                                                canSelectFolders: false,
                                                                                                canSelectMany: false,
                                                                                                openLabel:
                                                                                                    "Select GLEW DLL",
                                                                                            }
                                                                                        )
                                                                                        .then(
                                                                                            (
                                                                                                glewDLLPath
                                                                                            ) => {
                                                                                                if (
                                                                                                    !glewDLLPath ||
                                                                                                    glewDLLPath.length ===
                                                                                                        0
                                                                                                ) {
                                                                                                    vscode.window.showErrorMessage(
                                                                                                        "GLEW DLL not selected. Aborting project creation."
                                                                                                    );
                                                                                                    return;
                                                                                                }

                                                                                                // Select the library files
                                                                                                vscode.window
                                                                                                    .showOpenDialog(
                                                                                                        {
                                                                                                            canSelectFiles: true,
                                                                                                            canSelectFolders: false,
                                                                                                            canSelectMany: false,
                                                                                                            openLabel:
                                                                                                                "Select libglfw3dll.a file",
                                                                                                        }
                                                                                                    )
                                                                                                    .then(
                                                                                                        (
                                                                                                            libGLFWFilePath
                                                                                                        ) => {
                                                                                                            if (
                                                                                                                !libGLFWFilePath ||
                                                                                                                libGLFWFilePath.length ===
                                                                                                                    0
                                                                                                            ) {
                                                                                                                vscode.window.showErrorMessage(
                                                                                                                    "libGLFW file not selected. Aborting project creation."
                                                                                                                );
                                                                                                                return;
                                                                                                            }

                                                                                                            vscode.window
                                                                                                                .showOpenDialog(
                                                                                                                    {
                                                                                                                        canSelectFiles: true,
                                                                                                                        canSelectFolders: false,
                                                                                                                        canSelectMany: false,
                                                                                                                        openLabel:
                                                                                                                            "Select glew32.lib file",
                                                                                                                    }
                                                                                                                )
                                                                                                                .then(
                                                                                                                    (
                                                                                                                        libGLEWFilePath
                                                                                                                    ) => {
                                                                                                                        if (
                                                                                                                            !libGLEWFilePath ||
                                                                                                                            libGLEWFilePath.length ===
                                                                                                                                0
                                                                                                                        ) {
                                                                                                                            vscode.window.showErrorMessage(
                                                                                                                                "libGLEW file not selected. Aborting project creation."
                                                                                                                            );
                                                                                                                            return;
                                                                                                                        }

                                                                                                                        createOpenGLProject(
                                                                                                                            projectName,
                                                                                                                            selectedFolder.fsPath,
                                                                                                                            compilerPath[0]
                                                                                                                                .fsPath,
                                                                                                                            glfwFolder[0]
                                                                                                                                .fsPath,
                                                                                                                            glewFolder[0]
                                                                                                                                .fsPath,
                                                                                                                            openGLDLLPath[0]
                                                                                                                                .fsPath,
                                                                                                                            glfwDLLPath[0]
                                                                                                                                .fsPath,
                                                                                                                            glewDLLPath[0]
                                                                                                                                .fsPath,
                                                                                                                            libGLFWFilePath[0]
                                                                                                                                .fsPath,
                                                                                                                            libGLEWFilePath[0]
                                                                                                                                .fsPath
                                                                                                                        );

                                                                                                                        const projectFolderPath =
                                                                                                                            path.join(
                                                                                                                                selectedFolder.fsPath,
                                                                                                                                projectName
                                                                                                                            );
                                                                                                                        vscode.commands.executeCommand(
                                                                                                                            "vscode.openFolder",
                                                                                                                            vscode.Uri.file(
                                                                                                                                projectFolderPath
                                                                                                                            ),
                                                                                                                            false
                                                                                                                        );
                                                                                                                    }
                                                                                                                );
                                                                                                        }
                                                                                                    );
                                                                                            }
                                                                                        );
                                                                                }
                                                                            );
                                                                    }
                                                                );
                                                        });
                                                });
                                        });
                                });
                        });
                }

                // Start the project creation process
                promptForProjectDetailsAndCreateProject();
            }
        );

    context.subscriptions.push(generateOpenGLProjectCommandDisposable);

    // Dispose of the command when the extension is deactivated
    context.subscriptions.push(generateProjectCommandDisposable);

    //context.subscriptions.push(generateFunctionBodiesCommandDisposable);

    // Register the context menu contribution
    context.subscriptions.push(
        vscode.commands.registerCommand(
            "betterCPP.createCplusplusClass",
            (uri) => {
                vscode.window.showInformationMessage(
                    `Creating C++ class at ${uri.fsPath}`
                );
                vscode.commands.executeCommand("betterCPP.createClass", uri);
            }
        )
    );

    context.subscriptions.push(synchronizeFunctionDeclarationDisposable);

    context.subscriptions.push(createClassCommandDisposable);

    //context.subscriptions.push(generateGetSetCommandDisposable);
}

function deactivate() {
    // This method is called when your extension is deactivated
}

module.exports = {
    activate,
    deactivate,
};
